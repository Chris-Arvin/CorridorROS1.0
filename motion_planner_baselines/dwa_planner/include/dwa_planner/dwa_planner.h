#ifndef _DWA_PLANNER_H_
#define _DWA_PLANNER_H_

#include <geometry_msgs/Twist.h>
#include <geometry_msgs/Pose.h>
#include <base_local_planner/costmap_model.h>
#include <tf/tf.h>
#include <ros/publisher.h>
#include <nav_msgs/Path.h>
#include "dwa_planner/utils.h"

namespace dwa_planner
{
class DWAPlanner
{
public:
  DWAPlanner(base_local_planner::CostmapModel* costmap_model, const std::vector<geometry_msgs::Point>& footprint_spec,
             double inscribed_radius, double circumscribed_radius, const DWAConfig& cfg, ros::NodeHandle nh);
  virtual ~DWAPlanner();

  bool computeVelocityCommands(const Velocity& robot_vel, const Pose2D& robot_pose,
                               const std::vector<Pose2D>& global_plan, unsigned char const* const* costmap, int size_x,
                               int size_y, double resolution, double origin_x, double origin_y, Velocity& cmd_vel);
  void wolrd2map(const double& wx, const double& wy, int& mx, int& my, const double& resolution, const double& origin_x, const double& origin_y);
  /**
   * @brief sample potential velocities from v space and w space
   * @param robot_vel: current velocity
   * @param sample_vel: sampled (v,w). to be calculated.
   * @return \c true, if has potential velocity, \c false otherwise
   */
  bool samplePotentialVels(const Velocity& robot_vel, std::vector<Velocity> & sample_vels);
  /**
   * @brief compute next velocity. v= v0+a*dt or the limitation of velocity
   * @param sample_target_vel: target velocity
   * @param vel: current velocity in simulation
   * @return next velocity in simulatoin
   */
  Velocity computeNewVelocities(const Velocity &sample_target_vel, const Velocity &vel);
  /**
   * @brief compute new pose. dx=v1*dt,dw=w1*dt
   * @param pos: current pos in simulation
   * @param vel: current velocity in simulation
   * @return next Pose in simulation
   */
  Pose2D computeNewPose(const Pose2D &pos, const Velocity &vel);
  /**
   * @brief simulate sim_time_samples steps to generate a trajectory 
   * @param robot_vel: current velocity of the robot
   * @param robot_pose: current pose of the robot
   * @param sample_vel: the sampled velocity (v,w) for simulation
   * @return a potential trajectory
   */
  Trajectory generateTrajectory(const Velocity& robot_vel, const Pose2D& robot_pose, const Velocity& sample_vel);
  /**
   * @brief score a trajectory from collision, distance to local goal and distance to reference path
   * @param traj: a potential trajectory
   * @param params of local map: size_x, size_y, resolution, origin_x, origin_y, costmap
   * @param global_plan: global path generated by global planner
   * @return score for traj
   */
  double scoreTrajectory(Trajectory& traj, const int& size_x, const int& size_y, const double& resolution, const double& origin_x, const double& origin_y, const std::vector<Pose2D>& global_plan, unsigned char const* const* costmap);
private:
  /**
   * @brief Check whether the planned path is feasible or not.
   *
   * This method currently checks only that the path, or a part of the path is collision free.
   * Obstacles are here represented as costmap instead of the internal ObstacleContainer.
   * @return \c true, if the robot footprint along the first part of the path intersects with
   *         any obstacle in the costmap, \c false otherwise.
   */
  bool isPathFeasible(const std::vector<Pose2D>& path);
  void publishCandidatePaths(const std::vector<std::vector<Pose2D> >& candidate_paths);
  void publishFinalTraj(Trajectory& traj);

private:
  const DWAConfig* cfg_;  //!< Config class that stores and manages all related parameters

  base_local_planner::CostmapModel* costmap_model_;   //!< Pointer to the costmap model
  std::vector<geometry_msgs::Point> footprint_spec_;  //!< The specification of the footprint of the robot in world
                                                      //!< coordinates
  double inscribed_radius_;                           //!< The radius of the inscribed circle of the robot
  double circumscribed_radius_;                       //!< The radius of the circumscribed circle of the robot

  ros::Publisher candidate_paths_pub_;
  ros::Publisher following_traj_pub_;
};

}  // namespace dwa_planner

#endif  // _DWA_PLANNER_H_